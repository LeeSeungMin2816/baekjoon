# 9506 C 풀이

- 문제:  
정수 n이 주어질 때, n의 자기 자신을 제외한 모든 양의 약수(진약수)의 합이 n과 같으면 n을 완전수라고 한다. 여러 개의 n이 입력될 때 각 n에 대해 완전수 여부를 판단하라. (입력은 -1로 종료)

- 입력:  
여러 줄에 걸쳐 정수 n이 한 줄에 하나씩 주어진다. 마지막 줄은 -1이며 이 값은 처리하지 않는다.

- 출력:  
각 n마다 완전수이면 `n = d1 + d2 + ... + dk` 형태로, 아니면 `n is NOT perfect.`를 출력한다.

- 예제 입력:
```
6
12
28
-1
```

- 예제 출력:
```
6 = 1 + 2 + 3
12 is NOT perfect.
28 = 1 + 2 + 4 + 7 + 14
```

- 링크:  
https://www.acmicpc.net/problem/9506

## 필요한 개념
- **완전수**와 **진약수**의 정의
- **효율적인 약수 탐색**: `i = 2..⌊√n⌋`까지 검사하며 약수 쌍 `(i, n/i)`를 함께 처리. `i*i == n`일 때는 한 번만 더한다.

## C 코드
```c
#include <stdio.h>
#include <math.h>

int main(void) {
    int n;
    while (scanf("%d", &n) == 1) {
        if (n == -1) break;

        if (n == 1) {
            printf("1 is NOT perfect.\n");
            continue;
        }

        int divs[1000];
        int size = 0;
        int sum = 1;
        divs[size++] = 1;

        int limit = (int)sqrt((double)n);
        for (int i = 2; i <= limit; ++i) {
            if (n % i == 0) {
                divs[size++] = i;
                sum += i;
                int j = n / i;
                if (j != i) {
                    divs[size++] = j;
                    sum += j;
                }
            }
        }

        if (sum == n) {
            for (int i = 0; i < size-1; i++) {
                for (int j = i+1; j < size; j++) {
                    if (divs[i] > divs[j]) {
                        int tmp = divs[i];
                        divs[i] = divs[j];
                        divs[j] = tmp;
                    }
                }
            }
            printf("%d = %d", n, divs[0]);
            for (int k = 1; k < size; k++) {
                printf(" + %d", divs[k]);
            }
            printf("\n");
        } else {
            printf("%d is NOT perfect.\n", n);
        }
    }
    return 0;
}
```
