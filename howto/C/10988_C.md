# 10988 C 언어 풀이 (팰린드롬인지 확인하기)

## 문제
주어진 단어가 팰린드롬(앞에서 읽으나 뒤에서 읽으나 같은 문자열)인지 판별하여, 맞으면 1, 아니면 0을 출력한다.

- 링크: <https://www.acmicpc.net/problem/10988>

---

## 핵심 개념
- **팰린드롬(Palindrome)**: 좌우가 대칭인 문자열
- 문자열의 양 끝 인덱스를 좁혀가며 비교하는 **투 포인터** 방식이 단순하고 빠르다.

---

## 알고리즘 개요
1. 문자열 `s`를 입력받는다.
2. `i=0`, `j=len(s)-1`로 두 포인터를 두고 `s[i]`와 `s[j]`를 비교한다.
3. 하나라도 다르면 팰린드롬 아님 → `0` 출력.
4. 끝까지 문제 없으면 팰린드롬 → `1` 출력.

시간복잡도: O(n)  
공간복잡도: O(1)

---

## C 코드 (투 포인터, 개행 제거까지 처리)

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// 문자열 s가 팰린드롬이면 true, 아니면 false
bool is_palindrome(const char *s) {
    int i = 0, j = (int)strlen(s) - 1;
    while (i < j) {
        if (s[i] != s[j]) return false;
        i++; j--;
    }
    return true;
}

int main(void) {
    char s[110];                 // 문제 길이 여유로 100+여유
    if (!fgets(s, sizeof(s), stdin)) return 0;

    // 개행 문자 제거
    size_t len = strlen(s);
    if (len > 0 && s[len - 1] == '\n') s[len - 1] = '\0';

    printf("%d\n", is_palindrome(s) ? 1 : 0);
    return 0;
}
```

---

## 대안 (공백 없는 입력이라면 간단히 scanf 사용)

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool is_palindrome(const char *s) {
    int i = 0, j = (int)strlen(s) - 1;
    while (i < j) {
        if (s[i] != s[j]) return false;
        i++; j--;
    }
    return true;
}

int main(void) {
    char s[110];
    scanf("%109s", s);           // 공백 전까지 읽기
    printf("%d\n", is_palindrome(s) ? 1 : 0);
    return 0;
}
```

---

## 테스트 예시
입력:
```
level
```
출력:
```
1
```
입력:
```
baekjoon
```
출력:
```
0
```
